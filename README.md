# 为什么使用内存池

主要目的是防止小块内存的频繁开辟（分配）和释放。因为这种操作会使内存碎片化，从而导致内存没有更多的连续的大块的内存块。

# Memory-Pool-nginx

剖析Nginx的内存池源码+移植代码，能够理解其基本原理实现以及内存池设计的应用场景

# 剖析nginx的内存池源码

首先Nginx 内存池的实现在 ngx_palloc.c 文件中。

通过阅读nginx内存池源码可以简单了解到：

内存池初始化：Nginx在启动时会初始化内存池，根据测试用例的大小来判断是小块内存分配还是大块内存分配。内存池的初始化包括分配一块大内存，并将其划分成多个大小不等的内存块，以备后续分配使用。

内存池结构：Nginx的内存池是基于 ngx_pool_s 结构的。这个结构包含了内存池的各种信息，比如：内存池的主体信息，小块内存数据的头信息，大块内存的类型定义，清理操作的类型定义（回调函数）

内存分配：Nginx使用内存池进行内存分配，而不是直接调用系统的 malloc() 函数，内存分配的核心函数是 ngx_palloc()，其实这个函数的底层也是调用malloc函数实现的。

内存释放：Nginx内存池提供了 ngx_pfree() 函数（底层也是调用free函数）来释放之前分配的内存块。

内存池销毁：当 Nginx退出时，会调用 ngx_destroy_pool() 函数来销毁内存池，并释放所有与之相关的内存块。

内存对齐：Nginx内存池会对内存块进行字节对齐，以便为了提高内存访问效率。

# 注意
Nginx大块内存的分配是通过内存释放ngx_free函数

但是对于Nginx小块内存，没有提供任何的内存释放函数，从小块内存的分配方式看，小块内存是通过last指针偏移来实现内存分配的，所有也没有办法进行小块内存的回收。

Nginx本质是http服务器，它是一个短链接的服务器，客户端发起一个request请求，到达Nginx服务器以后，处理完成后，Nginx给客户端返回一个response响应，http服务器就主动断开tcp连接，http服务器返回响应后，等待一定时间（自己设定的），如果这个时间内客户端又发来请求，则重置时间，否则时间到达之后，Nginx主动断开连接，此时Nginx可以调用ngx_reset_pool重置内存池。等待下一次客户端请求....



#  Memory-Pool-SGI

剖析SGI-STL二级空间配置器的内存池源码+移植代码，能够理解其基本原理实现以及内存池设计的应用场景

# 剖析SGI-STL二级空间配置器内存池源码

通过阅读源码，我们不难发现其实SGI STL有两个allocator空间分配实现，一个是一级allocator内存管理，和C++标准库中提供的allocator是一样的，都是通过malloc和free实现的。另一个是二级allocator内存池的实现，其是基于freelist自由链表原理的内存池机制实现内存管理。

在我们在学C++STL时，标准容器空间配置器里面有四大函数：allocate负责给容器开辟内存空间-malloc实现，deallocate负责释放容器内存空间-free实现，construct负责给容器构造一个对象-定位new实现，destroy负责析构容器的对象-~T()实现。其功能就是分离了对象的内存开辟和对象构造。分离了对象的析构和内存的释放。

# SGI STL二级空间配置器内存池实现的优点

对于每一个字节数chunk块的使用分配，其底部实现均进行备用处理。即一部分进行使用，一部分进行备用。而备用的chunk块不仅可以只为当前字节数使用，还可以提供给其他适配的字节数使用。

对于当前字节数chunk块极小的剩余内存块，也会提供给其他字节数使用，进行再分配。内存丝毫不会浪费

对于指定的字节数内存分配失败，会有一个异常处理的过程-对所有的chunk块进行检查，如果哪个字节数有空闲的chunk块，当前字节数就会直接进行使用

如果上面操作失败，系统还会调用一个预先设置好内存malloc分配失败的回调函数，也就是oom_malloc函数。如果没设置，调用malloc函数会抛出bad_alloc的异常，如果设置了，会进入死循环，一直尝试调用oom_malloc_handler函数,malloc函数。



